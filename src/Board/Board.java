//The board class. This contains a board, a single level of the game, and all the associated
//functions. It is the main class for the running of the game, with 'moveball' being what
//the main loop repeatedly calls.

package Board;


import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.LinkedList;
import java.util.Vector;
import Board.Pieces.*;
import GFX.GFXLibrary;
import Sound.SoundLibrary;

public class Board
{
			
	
	private URL codeBase; //the URL of the applet's location 
    public int boardWidth; // board dimensions in tiles
    public int boardPixelWidth; // board dimensions in pixels, namely the width of a tile
    							//times the boardWidth
    
    //Statistics about the various balls
    public int maxSecondsAllowed; //the maximum seconds allowed to complete the level
    public int timeRemaining; //time remaining before failure
    public int minBallsForSuccess; //the minimum number of balls needed to complete the level
    public int maxBallsDestroyed; //maximum balls that can be destroyed before failure
    public int ballsInPlay; //number of balls currently on the field 
    public int ballsRemainingToEnter; //number of balls awaiting to enter play
    
    public int ballsDestroyed; //number of balls that have exploded
    public int ballsFinished; //the number of balls that have reached the end of the maze
    
    public Piece pieces [] []; // board pieces    
    public LinkedList<Piece> selectList; //list of selected tiles (with blue highlights)
    public boolean dragEnabled; //a flag to determine whethor new tiles should be added
    
    
    //the graphics and sound library are called repeatedly in various places
    public GFXLibrary gfxLibrary;
    public SoundLibrary soundLibrary;

    int clickCounter=0;    //counts the frames between audible 'clicks' that are played

    //the board area is a square image. When a render is called, the board area is returned
    BufferedImage boardArea;
    Graphics2D boardAreaG2D;
    
    //Game status flags: the game loop exits if a level is complete, and the next level is
    //loaded if the level was not failed.
    public boolean levelComplete=false;
    public boolean levelFailed=false;
  
    public boolean doneLoading=false; //set to true when board.loadBoard finishes

    public PosAndDist[] balls; //list of all balls that will ever apear on a given board
 
    
    public boolean ballHasCollided[]; //keeps track of whethor a ball has colided in a given
    								  //iteration. This is to prevent a ball from rebounding
    								  //multiple times off the same ball.
    
    public int ballCollideCounter=0;  //counts the number of collisions a ball has made 
   
    
    public int numBalls; //number of balls that will be released in the level
    public int ballFrameCounter; //the frame of the ball animation to be displayed (loops 1-20)
   
    public float defaultBallSpeed=3f; //default ball speed
    public int ragePerRebound=50; //amount of rage generated by each bounce
    public int explodeRage=400; //rage needed to explode
    
    public Vector<Piece> securityList; //list of tiles effected by security (have turned yellow)
    
    public LinkedList<sfx> explosionList; //list of explosions, and their location on screen
    public LinkedList<sfx> summonList; //list of summoning special effects and their location
    
    //constructor, instantiate the board
    public Board(GFXLibrary gfxLibrary, SoundLibrary soundLibrary, URL codeBase)
    {
    	
    	this.gfxLibrary=gfxLibrary;
    	this.soundLibrary=soundLibrary;
    	this.codeBase=codeBase;
    	selectList=new LinkedList<Piece>();
    	securityList=new Vector<Piece>();
    	explosionList=new LinkedList<sfx>();
    	summonList=new LinkedList<sfx>();
    }

    //this method draws all the various special effects at their propper location
    public void handleSFX()
    {
    	sfx currentSFX;
    	int numExplosions=explosionList.size();
    
    	for (int x=0; x<numExplosions; x++)
    	{
    		//for each explosion int he list, poll the top one
    		currentSFX=explosionList.pollFirst();
    		//draw it's location
    		boardAreaG2D.drawImage(gfxLibrary.explosion[currentSFX.frame], currentSFX.x, currentSFX.y, null);
    		//incriment it's frame counter
    		currentSFX.frame++;
    		//if the animation is not complete, return it to the list
    		if (currentSFX.frame<12)
    		{
    		explosionList.add(currentSFX);
    		}//end if still has frames to show
    	}//for all explosions
    	int numSummons=summonList.size();
    	for (int x=0; x<numSummons; x++)
    	{
    		currentSFX=summonList.pollFirst();
    		
    		boardAreaG2D.drawImage(gfxLibrary.summon[currentSFX.frame], currentSFX.x, currentSFX.y, null);
    		
    		currentSFX.frame++;
    		if (currentSFX.frame<32)
    		{
    		summonList.add(currentSFX);
    		}//end if still has frames to show
    	}//for all explosions
    	
    }//end handleSFX
    
    //loadboard, not surprisingly, loads the board who's filename is specified
    //the board must be of exacting format, and located in the root directory
    public void loadBoard(String boardName)
    {
        //System.out.println("Loading Board");
        URL url = null;
        try
        {
          url = new URL(codeBase, boardName);
        }
        catch(Exception  e)
        {
        	System.out.println("Malformed URL triggered in loadBoard");
        } //end catch
        
        try
	    {
	        InputStream in = url.openStream();
	        //easy reader is a simple input stream reader with some handy functionality
	        EasyReader easyReader=new EasyReader(in);
	      	//get the maximum time allowed
	        easyReader.readString();
	      	maxSecondsAllowed = easyReader.readInt ();
	      	timeRemaining=maxSecondsAllowed*100;
	      	
	      	// Get Board Size
	      	easyReader.readString();
	      	boardWidth=easyReader.readInt();
	      	boardPixelWidth=boardWidth*gfxLibrary.pieceSize;
	      	// Create the board
	
	      	pieces = new Piece [boardWidth] [boardWidth];
	      	boardArea=new BufferedImage(boardWidth*gfxLibrary.pieceSize, boardWidth*gfxLibrary.pieceSize, BufferedImage.BITMASK);
	      	boardAreaG2D=(Graphics2D)boardArea.getGraphics();
	      	
	      	//read the number of startpieces
	      	easyReader.readString();
	      	int numStartPieces=easyReader.readInt();
	      	int startPieceCounter=0;
	      	int startPiecesX[]=new int[numStartPieces];
	      	int startPiecesY[]=new int[numStartPieces];
	      	//read the number of balls
	      	easyReader.readString();
	      	numBalls=easyReader.readInt();
	      	balls=new PosAndDist[numBalls];
	      	
	      	easyReader.readString();
	      	minBallsForSuccess=easyReader.readInt();
	      	maxBallsDestroyed=numBalls-minBallsForSuccess;
	        ballHasCollided=new boolean[numBalls];
	        //0=not in play, 1=in play, 2=accelerated, 3=decelerated, 4=finished
	        
	      	ballFrameCounter=0;
	      	
	      	// Read the pieces
	
	      	for (int y = 0 ; y < boardWidth ; y++)
	      	{
	      	    for (int x = 0 ; x < boardWidth ; x++)
	      	    {
		
		      		// Get the next piece
		
		      		String name = easyReader.readWord ();
		   		    Piece p;
		      		
		   		    //each type of piece has a 2 letter character
			      	if (name.equals ("hz")) 
			      	    p = new StraightPiece ("hz", 90, this, gfxLibrary, x, y);
			      	else if (name.equals ("vt"))//vt=vertical
			      		p = new StraightPiece ("vt", 0, this, gfxLibrary, x, y);
			      	else if (name.equals ("ul")) //ul=upper left, reffering to the position of the inner corner of the elbow shape			     
			      		p = new ElbowPiece ("ul", 270, this, gfxLibrary, x, y);
			      	else if (name.equals ("ur")) //ur=upper right
			      		p = new ElbowPiece ("ur", 0, this, gfxLibrary, x, y);
			      	else if (name.equals ("lr")) //lr = lower right
			      		p = new ElbowPiece ("lr", 90, this, gfxLibrary, x, y);
			      	else if (name.equals ("ll")) //ll=lower left
			      		p = new ElbowPiece ("ll", 180, this, gfxLibrary, x, y);
			      	else if (name.equals ("bp")) //blocker piece
			      		p = new BlockerPiece ("bp", this, gfxLibrary, x, y);
			      	else if (name.equals ("sp")) //start piece
			      	{			      		
			      		//if a start piece is found, we don't initiate it right away, we wait
			      		//until the parameters are specified.
			      		startPiecesX[startPieceCounter]=x;
			      		startPiecesY[startPieceCounter]=y;
			      		p=null;
			      		startPieceCounter++;		
			      	}
			      	else if (name.equals ("ep")) //end piece
			      		p =  new EndPiece ("ep", 180, this, gfxLibrary, x, y);
			      	else if (name.equals ("fw")) //four-way piece
			      		p = new FourwayPiece("fw", this, gfxLibrary, x, y);
			      	else if (name.equals ("eq")) //encryption
			      		p = new EncryptionPiece("eq", this, gfxLibrary, x, y);
			      	else if (name.equals ("ic")) //iceCode
			      		p = new IcePiece("ic", this, gfxLibrary, x, y);
			      	else
			      		p = null;
			      	
			      	
		      		pieces [x] [y] = p;
		      		if (p!=null)
		      		{
		      			p.updateCachedImage();
		      		}
		      		
	      	    }//end for x to xDim
	      	}//end for y to ydim
	      	
	      	easyReader.readString();
	      	StartPiece p;
	      	int numBallsAtSP;
	      	int ballCounter=0;
	      	//for each startpiece, we initiate based on the read parameters. We
	      	//then initiate the balls that will spawn in this start piece, including
	      	//the time which they will arrive at.
	      	for (startPieceCounter=0; startPieceCounter<numStartPieces; startPieceCounter++)
	      	{
	      		p=new StartPiece ("sp", easyReader.readInt(), this, gfxLibrary, startPiecesX[startPieceCounter], startPiecesY[startPieceCounter]);
	      		pieces[p.posX][p.posY]=p;
	      		p.updateCachedImage();
	      		numBallsAtSP=easyReader.readInt();
	      		for (int x=0; x<numBallsAtSP; x++)
	      		{
	      			//balls initial velocity varies depending ont he rotation of the start piece
		      		balls[ballCounter]=new PosAndDist();
		      		if (p.rotation==0)
		      		{
		      		balls[ballCounter].vx=-1;
		      		balls[ballCounter].vy=0;
		      		}
		      		else if (p.rotation==180)
		      		{
			      		balls[ballCounter].vx=1;
			      		balls[ballCounter].vy=0;
			        }
		      		else if (p.rotation==90)
		      		{
			      		balls[ballCounter].vx=0;
			      		balls[ballCounter].vy=-1;
			        }
		      		else 
		      		{
			      		balls[ballCounter].vx=0;
			      		balls[ballCounter].vy=1;
			        }
		      		//initiate the rest of the balls variables
		      		balls[ballCounter].x=p.posX*gfxLibrary.pieceSize+gfxLibrary.pieceSize/2;
		      		balls[ballCounter].y=p.posY*gfxLibrary.pieceSize+gfxLibrary.pieceSize/2;
		      		balls[ballCounter].distance=0;
		      		balls[ballCounter].tileX=(int)(balls[ballCounter].x/((float)gfxLibrary.pieceSize));
		      		balls[ballCounter].tileY=(int)(balls[ballCounter].y/((float)gfxLibrary.pieceSize));
		      		balls[ballCounter].inPlay=false;
		      		balls[ballCounter].awaitingEntrance=true;
		      		balls[ballCounter].inPlayCounter=easyReader.readInt();
		      		
		      		
		      		ballCounter++;
	      		}
	      	}//end for startPieceCounter=0 to numStartPieces
	      	
        } //end try open inputstream
        catch(Exception e)
        {
          e.printStackTrace();
        }//end catch
        //set the flags to indicate the level is ready to begin
        levelComplete=false;
        levelFailed=false;
        doneLoading=true;
      }//end loadboard
    
   
    //level complete checks the status of the balls and
    //updates flags appropriately
    public void updateLevelComplete()
    {
    	//we assume the level is not complete and has not been failed until
    	//proven otherwise
    	levelComplete=false;
    	levelFailed=false;
    	
    	ballsFinished=0;
    	ballsDestroyed=0;
    	ballsRemainingToEnter=0;
    	ballsInPlay=0;
    	for (int x=0; x<numBalls; x++)
    	{
    		if (balls[x].destroyed)
    		{
    			ballsDestroyed++;
    		}
    		if (balls[x].finished)
    		{
    			ballsFinished++;
    		}
    		if (balls[x].awaitingEntrance)
    		{
    			ballsRemainingToEnter++;
    		}
    		if (balls[x].inPlay)
    		{
    			ballsInPlay++;
    		}
    	}//for x=0 to numballs
    	if ((ballsDestroyed>maxBallsDestroyed)||(timeRemaining<=0))
    	{
    		
    		//System.out.println("failure "+ ballsDestroyed+" "+maxBallsDestroyed+" " +timeRemaining);
    		levelFailed=true;
    		levelComplete=true;
    	}
    	else if (ballsFinished>=minBallsForSuccess)
    	{
    		//System.out.println("Success "+ ballsFinished+" "+minBallsForSuccess);
    		levelComplete=true;
    	}
    }//end updateLevelComplete
    
    //this draws the board, the viruses, and any special effects. The board is returned
    //as a squarer buffered image, which is then scaled down and displayed
    public BufferedImage drawBoard()
    {
    	
    	
    	boardAreaG2D.setColor(Color.BLACK);
    	//first we draw a black backdrop to clear the old board
    	boardAreaG2D.fillRect(0,0,boardPixelWidth,boardPixelWidth);
    	//now we draw each ball. The tiles are drawn overtop, but the
    	//areas the ball can move in are transparent. This means that if a ball
    	//hits a wall it is drawn 'under' the tile, which is more aesthetically pleasing
    	//than clipping overtop of it
    	for (int x=0; x<numBalls; x++)
    	{
    		if (balls[x].inPlay)
    		{
    		    
    			//we choose which ball to draw based on that balls rage
    		    if (balls[x].rage<(explodeRage*0.25))
    		    {
    		    	//if we have a 'calm' ball that has been decelerated,
    		    	//we draw it as yellow
    		    	if (balls[x].decelerated)
        		    {
        		    	boardAreaG2D.drawImage(gfxLibrary.virusYellowAlert[ballFrameCounter], (int)(balls[x].x-gfxLibrary.virusSize/2),(int)(balls[x].y-gfxLibrary.virusSize/2), null);
        		    }
    		    	//otherwise calm balls are drawn neutral blue
    		    	else
    		    	{
    		    	boardAreaG2D.drawImage(gfxLibrary.virus[ballFrameCounter], (int)(balls[x].x-gfxLibrary.virusSize/2),(int)(balls[x].y-gfxLibrary.virusSize/2), null);
    		    	}
    		    }
    		    //excited balls go from pink to orange to red, before exploding.
    		    //At this point the programmer would like to apologize for the
    		    //HORRIBLE inuendo he accidently birthed by naming an important variable 
    		    //"balls"
    		    else if (balls[x].rage<(explodeRage*0.50))
    		    {
    		    	boardAreaG2D.drawImage(gfxLibrary.virusWarning1[ballFrameCounter], (int)(balls[x].x-gfxLibrary.virusSize/2),(int)(balls[x].y-gfxLibrary.virusSize/2), null);
    		    }
    		    else if (balls[x].rage<(explodeRage*0.75))
    		    {
    		    	boardAreaG2D.drawImage(gfxLibrary.virusWarning2[ballFrameCounter], (int)(balls[x].x-gfxLibrary.virusSize/2),(int)(balls[x].y-gfxLibrary.virusSize/2), null);
    		    }    		   
    		    else if (balls[x].rage>=(explodeRage*0.75))
    		    {
    		    	boardAreaG2D.drawImage(gfxLibrary.virusRedAlert[ballFrameCounter], (int)(balls[x].x-gfxLibrary.virusSize/2),(int)(balls[x].y-gfxLibrary.virusSize/2), null);
    		    }
    		}//end if ball in play
    	}//end for x=0 to numballs
    	//we incriment the frame counter for the balls, reseting to 0 if it is greater
    	//than the number of frames the ball animation posseses
    	ballFrameCounter++;
    	if (ballFrameCounter>=gfxLibrary.virusNumFrames)
    		ballFrameCounter=0;
    	//with the balls drawn, we draw the tiles
    	for(int x=0; x<boardWidth; x++)
    	{
    		for(int y=0; y<boardWidth; y++)
        	{
    			if (pieces[x][y]!=null)
    			{
    				boardAreaG2D.drawImage(pieces[x][y].getImage(),pieces[x][y].getTransform(),null);
    				
    			}//end if piece !=null
        	}	//end y to boardwidth
    	}//end x to boardwidth
    
    	//finally, we draw the SFX, which is handled in a seperate function
    	handleSFX();
    	
    	return boardArea;
    }//end drawBoardArea

    //this function updates the yellow and red tiles, turning
    //off yellow tiles that have been yellow too long, and turning
    //on red tiles that may have been mistakenly turned off when a
    //ball exited them (but another ball still remains)
    public void updateSecurityList()
    {
    	//turn off yellow tiles as appropriate
    	for (int x=0; x<securityList.size(); x++)
    	{
    		securityList.elementAt(x).securityCount=securityList.elementAt(x).securityCount-5;
    		if (securityList.elementAt(x).securityCount<=0)
    		{    			
    			securityList.elementAt(x).yellowSecurity=false;
    			securityList.elementAt(x).updateCachedImage();    			
    			securityList.remove(x);
    			x--;
    		}//end if time is up
    			
    	}//for each yellow tile
    	
    	//turn on red tiles as appropriate
    	for (int x=0; x<numBalls; x++)
    	{
    		if (balls[x].inPlay)
    		{
    			pieces[balls[x].tileX][balls[x].tileY].redSecurity=true;
    			pieces[balls[x].tileX][balls[x].tileY].yellowSecurity=false;
    			pieces[balls[x].tileX][balls[x].tileY].securityCount=0;
    			pieces[balls[x].tileX][balls[x].tileY].updateCachedImage();
    		}
    	}//end for x=0 to numballs;
    }//end updateSecurityList
    
    //this checks the status of each ball. Balls with too much rage should explode,
    //balls that don't explode lose rage slightly over time, balls that are awaiting
    //entrance to the field come closer to their time, etc etc.
    public void updateBallStatus()
    {
    	for (int x=0; x<numBalls; x++)
    	{
    		//Exploding Balls Are Dangerous. For all balls that have more than the max rag
    		if (balls[x].rage>explodeRage)
    		{
    			//destroy ball and remove from play
    			balls[x].destroyed=true;
    			balls[x].inPlay=false;
    			balls[x].rage=0;
    			//make an explosion where the ball was
    			sfx newExplosion=new sfx();
    			newExplosion.x=(int) (balls[x].x-0.5*gfxLibrary.explosion[0].getHeight());
    			newExplosion.y=(int) (balls[x].y-0.5*gfxLibrary.explosion[0].getHeight());
    			newExplosion.frame=0;
    			//remove the red security from the tile (it will be restored if there is another
    			//ball still present
    			pieces[balls[x].tileX][balls[x].tileY].redSecurity=false;
    			//play an exploding sound
    			soundLibrary.playExplosion();
    			explosionList.add(newExplosion);
    		}
    		balls[x].rage=balls[x].rage-1;
    		if (balls[x].rage<0)
    		{
    			balls[x].rage=0;
    		}//end if rage is 0
    		//if the ball has been slowed down, it is only slowed for a limited time
    		//reduce the timer accordingly
    		if (balls[x].decelerated)
    		{
    			balls[x].decelerationCounter=balls[x].decelerationCounter-5;
    			//if the time is up, increase the speed again
    			if (balls[x].decelerationCounter<=0)
    			{
    				
    				balls[x].decelerated=false;
    				balls[x].decelerationCounter=0;
    				balls[x].distance=defaultBallSpeed;
    			}    			
    		}//end if decelerated
    		//if the ball is not in play, reduce the remaining time accordingly
    		if (balls[x].awaitingEntrance)
    		{
    			balls[x].inPlayCounter=balls[x].inPlayCounter-5;
    			
    			//if the ball is ready to enter play, put it there
    			if (balls[x].inPlayCounter<=0)
    			{
    				pieces[balls[x].tileX][balls[x].tileY].redSecurity=true;
    				balls[x].inPlay=true;
    				balls[x].awaitingEntrance=false;
    				balls[x].inPlayCounter=0;
    				balls[x].distance=defaultBallSpeed;
    			}
    			//if the ball is exactly 32 frames away from spawning, create
    			//the summoning animation to herald it's arival
    			else if (balls[x].inPlayCounter==160)
    			{
    				
    				sfx newSummon=new sfx();
        			newSummon.x=(int) (balls[x].x-0.5*gfxLibrary.summon[0].getHeight());
        			newSummon.y=(int) (balls[x].y-0.5*gfxLibrary.summon[0].getHeight());
        			newSummon.frame=0;
        			summonList.add(newSummon);
    			} 
    		}//end if decelerated
    	}//end for x=0 to numballs;
    }//end updateBallStatus
    
    //reverses a balls direction. adds rage.
    public void reverseBallDir(int ballNum)
    {
    	soundLibrary.playRebound();
    	
    	balls[ballNum].vx=-balls[ballNum].vx;
    	balls[ballNum].vy=-balls[ballNum].vy;
    	balls[ballNum].rage=balls[ballNum].rage+ragePerRebound;
    }
    
    //similar to the above, but modified to work without
    //the index number of the ball
    public void reverseBallDir(PosAndDist ball)
    {
    	soundLibrary.playRebound();
    	
    	ball.vx=-ball.vx;
    	ball.vy=-ball.vy;
    	ball.rage=ball.rage+ragePerRebound;
    }
    
    //this is the distance between two points, in pixels
    //where diagonals and horisontals are both counted as 1.
    public float getDistance (PosAndDist a, PosAndDist b)
    {
    	return Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y));
    }
    
    //This function, for a given ball i, computes the possibility (and results)
    //of a collison with the other balls
    public int collideBalls(int i)
    {
    	int collidedWith=-1;
    	for (int x=0; x<numBalls; x++)
    	{
    	   if (balls[x].inPlay)
    	   {
	    		if (i!=x)
	    		{
	    			if (getDistance(balls[x], balls[i])<16) //collision detected
	    			{
	    				collidedWith=x;    				
		    			//break the loop, we only want one rebound per colision.
	    			    x=numBalls+1;
	    			}//end 
	    		}   //end if i!=x
    	   }
    	}//end for x
    	
		return collidedWith;
    	
    }//end ballcollider
    
    //this function (predictably) moves the ball. It also updates the level complete
    //flags, updates the ball status, and generally manages the board.
    
    public void moveBall()
    {   
    	//update flags
    	updateLevelComplete();
    	//play a click every 4 frames
    	clickCounter++;
    	if (clickCounter==3)
    	{
    		clickCounter=0;
    		soundLibrary.playClick();
    	}
    	
    	timeRemaining=timeRemaining-5;
    	
    	//update the status of balls (deceleration and other fancy effects)
    	updateBallStatus();
    	
    	float distanceRemaining; //distance remaining to be moved
    	int currentPieceX, currentPieceY; //curent location of the ball
    	Piece currentPiece; //piece the ball is inside

    	// for all of the balls, we move them
    	for (int i=0; i<numBalls; i++)
    	{

	    	if (balls[i].inPlay)
	    	{
	    		//for this balls movement, no balls have collided
		    	for (int j=0; j<numBalls; j++)
		    	{
		    		ballHasCollided[j]=false;
		    	}
	
		    	//get the distance to move this round
			    distanceRemaining = balls[i].distance;
			    currentPieceX=balls[i].tileX;
			    currentPieceY=balls[i].tileY;
			    int nextCellX ;
			    int nextCellY;
	
		    	
			    do
			    {
	
			    	
					//move the ball
				    //System.out.println("Distance Remaining: "+distanceRemaining);
					distanceRemaining = pieces [currentPieceX] [currentPieceY].moveBall (balls[i], distanceRemaining);
			
					//this will only happen if the ball has moved outside a cell, and there is distance left over
					//the ball will be poised on the edge of the field, about to move into the next tile (IF it's valid)
					if (distanceRemaining > 0f)
					{
			
					    //we can do this because we know that vx and vy will
					    //always be 1, 0 or -1.
					    nextCellX = (int) (balls[i].vx + currentPieceX);
					    nextCellY = (int) (balls[i].vy + currentPieceY);
			
					    if ((nextCellX < 0) || (nextCellX >= boardWidth) || (nextCellY < 0) || (nextCellY >= boardWidth)) //case one: ball off the edge
					    {
						reverseBallDir (i);
						//we reverse the ball, and when the loop comes aroudn again, the next moveball call will deal with the extra distance
					    }
					    else if (pieces [nextCellX] [nextCellY] == null) //case 2: the tile you are looking for doesn't exist
					    {
						reverseBallDir (i);
						//Just like above, reverse the ball. The loop will pick up the difference in the next moveball call
					    }
					    else //case 3: it's a valid tile
					    {
						//more subdivides here... just cause it's a valid tile doesn't mean it's a tile with an appropriate entrance
					    // [0] = above; [1] = right; [2] = below; [3] = left
					    	int entranceDir=0;
					        if (balls[i].vy>0)
					        {
					        	entranceDir=0;
					        }
					        else if (balls[i].vy<0)
					        {
					        	entranceDir=2;
					        }
					        else if (balls[i].vx>0)
					        {
					        	entranceDir=3;	
					        }
					        else if (balls[i].vx<0)
					        {
					        	entranceDir=1;
					        }
					        
					        //entering from the specified direction is allowed and piece is not highlighted
						    if ((pieces [nextCellX] [nextCellY].entry [entranceDir])&&(!pieces [nextCellX] [nextCellY].selectHighlight)) 
						    {
								pieces [currentPieceX] [currentPieceY].isExiting (); //calls the entering code
								pieces [nextCellX] [nextCellY].isEntering (); //calls the exiting code
								currentPieceX = nextCellX; //ball entered successfully. A new cell is defined as the
								currentPieceY = nextCellY; // balls current position; the next loop will finish it.
								balls[i].tileX=nextCellX;
							    balls[i].tileY=nextCellY;
							    if (pieces[balls[i].tileX][balls[i].tileY].yellowSecurity)
							    {
							    	balls[i].decelerated=true;
							    	balls[i].decelerationCounter=200;
							    	balls[i].distance=defaultBallSpeed/3;
							    }
						    }//end if next tile has appropriate entrance
						    else
						    {
							reverseBallDir (i); //ball's not getting in here... let it turn around.
						    }
					    }//end if next tile is valid
					    		
					} //end if remaining distance>0
					  int collidedWith=collideBalls(i);
					  if (collidedWith!=-1)
					  {
						 
						    //if one ball rearended another (slower moving ball), only the fast
		    				//one should rebound.
			    			if ((balls[i].vx==balls[collidedWith].vx)&&(balls[i].vy==balls[collidedWith].vy))
			    			{
			    				//System.out.println("Rear End Type Collision");
			    				if (balls[i].distance>balls[collidedWith].distance)
			    				{
			    					if (!ballHasCollided[i])
				    				{
				    					//System.out.println("Ball I is the faster ball. Reversing.");
				    					ballHasCollided[i]=true;
				    					reverseBallDir(i);
				    					
				    				}
			    					else
			    					{
			    						//System.out.println("Ball I is the faster ball, but has already been collided. Did not reverse.");
			    					}
			    				}
			    				else
			    				{
			    					if (!ballHasCollided[collidedWith])
				    				{
				    					//System.out.println("Ball collidedWith is the faster ball. Reversing.");
					    				ballHasCollided[collidedWith]=true;
				    					reverseBallDir(collidedWith);
				    				}
			    					else
			    					{
			    						//System.out.println("Ball collidedWith is the faster ball, but has already been collided. Did not reverse.");
			    					}
			    				}
			    			}//end rear end collision
			    			//if two balls hit each other head on
			    			else
			    			{
			    				//System.out.println("Standard Collision");
			    				if (!ballHasCollided[i])
			    				{
			    					ballHasCollided[i]=true;
			    					reverseBallDir(i);
			    				}
			    				else
		    					{
		    						//System.out.println("Ball I has already collided. Did not reverse.");
		    					}
			    				
			    				if (!ballHasCollided[collidedWith])
			    				{		    			
				    				ballHasCollided[collidedWith]=true;
					    			reverseBallDir(collidedWith);
			    				}
			    				else
			    				{
			    					//System.out.println("Ball collidedWith has already collided. Did not reverse.");
			    				}
			    				
			    			}//end head on collision
			    			//System.out.println("Distance Remaining before Collision Adjustment: "+distanceRemaining);
			    			distanceRemaining=distanceRemaining+16-getDistance(balls[i], balls[collidedWith]);
			    			if (distanceRemaining<1)
			    			{
			    				distanceRemaining=0;
			    			}
			    			//System.out.println("Distance Remaining After Collision Adjustment: "+distanceRemaining);
			    			//System.out.println("--------------------------------------------");
	
					  }//end if a collision occured
			    }
			    while (distanceRemaining > 0f);
	    	}
	    }//end for i=0 to numballs
    	
    	//after moving balls, we update security codes (red and yellow tiles)
    	updateSecurityList();
    	
    }//end moveBall;
      
    //this function is a bit misnamed as it doesn't add a piece to the board,
    //but rather it adds a piece to the list of selected pieces
    public void addPiece(int pieceX, int pieceY)
    {
    	//dragenable is set to true when the mouse is pressed. If something causes
    	//processPieceList to be called, it is set to false, to prevent the user from
    	//accidenlty selecting further tiles
    	if (dragEnabled)
    	{
    		//if the piece is the last piece to be added, we do not add it again
	    	if (selectList.peekLast()!=pieces[pieceX][pieceY])
	    	{
	    		//these are all conditions which would cause us to terminate the drag
	    		if (pieces[pieceX][pieceY].redSecurity)
	    		{
	    			processPieceList();	
	    		}//end if redSecurity active on prospective piece
	    		else if (pieces[pieceX][pieceY].ICEd)
	    		{
	    			processPieceList();	
	    		}//end if ice  active on prospective piece
	    		else if (!pieces[pieceX][pieceY].movable)
	    		{
	    			processPieceList();
	    		}//end if piece not moveable

	    		else if (selectList.contains(pieces[pieceX][pieceY]))
	    		{
	    			processPieceList();
	    		}//end if  already in list
	    		else //if none of these conditions are met, we will add the pieces 
	    		{
	    			pieces[pieceX][pieceY].selectHighlight=true;
	    			//sets the yellow security to false. The security list will pick this up
	    			//during the next moveball call.
	    			pieces[pieceX][pieceY].securityCount=0;
	    			pieces[pieceX][pieceY].yellowSecurity=false;
	    			pieces[pieceX][pieceY].updateCachedImage();
	    			selectList.add(pieces[pieceX][pieceY]);
	    			
	    		}//if all conditions met, add to the list
	    			
	    	}//end if current piece selected != last peice of the list
    	}//end if drag enabled 
    }//end addPiece
    
    //this processes the user's action (shuffling or rotating the pieces)
    public void processPieceList()
    {
    	dragEnabled=false;
    	Piece currentPiece;
    	//if the list is empty for whatever reason, do nothing
    	if (selectList.size()>0)    		
    	{
    		//if the list contains only a single entry, rotate it.
    		if (selectList.size()==1)
    		{
    		currentPiece=selectList.pollLast();
    		currentPiece.selectHighlight=false;    		
    		currentPiece.rotate();
    		currentPiece.updateCachedImage();
    		soundLibrary.playRotate();
    		
    		}// if only one item
    		//otherwise there are multiple peices. Swap them end to end.
    		else 
    		{
	    		Piece first;
	    		Piece last;
	    		int tempX;
	    		int tempY;
	    		//iterate through the list, taking the first and last elements, swapping
	    		//their location ont he board, then discarding them from the list of selected
	    		//tiles. When we are down to 1 or less entries in the list, we can stop.
	    		while (selectList.size()>1)
	    		{
	    			first=selectList.pollFirst();
	    			last=selectList.pollLast();
	    			tempX=first.posX;
	    			tempY=first.posY;
	    			first.posX=last.posX;
	    			first.posY=last.posY;
	    			last.posX=tempX;
	    			last.posY=tempY;
	    			
	    			pieces[first.posX][first.posY]=first;
	    			pieces[last.posX][last.posY]=last;	    		
	    			
	    			first.selectHighlight=false;
	    			last.selectHighlight=false;
	    			
	    			first.updateCachedImage();
	    			last.updateCachedImage();
	    			soundLibrary.playSwap();
	    			
	    		}
	    		if (selectList.size()>0)
	    		{
	    			first=selectList.pollFirst();
	    			first.selectHighlight=false;
	    			first.updateCachedImage();
	    		}
    		}//end else
    	}//end if selectList.size>0
    }//end process list
    
    //this function dials up 2 random tiles and swaps them. It only swaps unocupied
    //unselected movable tiles, and consequently it's success is not gaurenteed
    
    public void performRandomSwap()
    {
    	//System.out.println("Random Swap Engaged");
    	boolean successA=false;
    	boolean successB=false;
    	int randomX1=0;
    	int randomY1=0;
    	int randomX2=0;
    	int randomY2=0;
    	int attemptCounter;
    	
    	attemptCounter=0;
    	
    	//basically we make 30 attempts to find a suitable tile
    	while ((!successA)&&(attemptCounter<30))
    	{
    		
    		attemptCounter++;
    		randomX1=(int)(Math.random()*(float)boardWidth);
        	randomY1=(int)(Math.random()*(float)boardWidth);
        	//suitable being defined as movable, unoccupied, and unselected
        	if (!pieces[randomX1][randomY1].redSecurity)
        	{
        		if (!pieces[randomX1][randomY1].selectHighlight)        	
        		{
            		if ((pieces[randomX1][randomY1].movable)||(pieces[randomX1][randomY1].name.equals("bp")))        	
            		{	
	        		successA=true;	        	
            		}//piece movable or a blocker
        		}//end if piece not selected
        	}//end if piece not red
    	}//end while !success
    	
    	attemptCounter=0;
    	//we then repeat the process with a second tile
    	while ((!successB)&&(attemptCounter<30))
    	{
    		attemptCounter++;
    		randomX2=(int)(Math.random()*(float)boardWidth);
        	randomY2=(int)(Math.random()*(float)boardWidth);
        	
        	if (!pieces[randomX2][randomY2].redSecurity)
        	{
        		if (!pieces[randomX2][randomY2].selectHighlight)        	
        		{
            		if ((pieces[randomX2][randomY2].movable)||(pieces[randomX2][randomY2].name.equals("bp")))        	
            		{	
	        		successB=true;	        	
            		}//piece movable or a blocker
        		}//end if piece not selected
        	}//end if piece not red
    	}//end while !success
    	
    	//if we have 2 valid tiles, we swap them
    	if (successA&&successB)
    	{
    		//System.out.println("Two Candidates Found: "+randomX1+" "+randomY1);
    		//System.out.println("                      "+randomX2+" "+randomY2);
    		Piece first;
    		Piece last;
    		int tempX;
    		int tempY;
    		
    			first=pieces[randomX1][randomY1];
    			last=pieces[randomX2][randomY2];
    			
    			tempX=first.posX;
    			tempY=first.posY;
    			first.posX=last.posX;
    			first.posY=last.posY;
    			last.posX=tempX;
    			last.posY=tempY;
    			
    			pieces[first.posX][first.posY]=first;
    			pieces[last.posX][last.posY]=last;	    		
    			
    			first.selectHighlight=false;
    			last.selectHighlight=false;
    			
    			first.updateCachedImage();
    			last.updateCachedImage();
    			soundLibrary.playSwap();
    	}//end if both searches are successful
    	
    }//end swap random
    
    //This selects a random tile and "ices it", making it immovable and unselectable
    public void performRandomICE()
    {
    	boolean success=false;
    	int randomX;
    	int randomY;
    	int attemptCounter=0;
    	//as before, a maximum of 30 attempts will be made before giving up.
    	//this means a heavily iced board becomes nearly immune to further ice
    	//(though it's a moot point by the time that happens as you've probably 
    	//already lost)
    	while ((!success)&&(attemptCounter<30))
    	{
    		attemptCounter++;
    		randomX=(int)(Math.random()*(float)boardWidth);
        	randomY=(int)(Math.random()*(float)boardWidth);
        	if (!pieces[randomX][randomY].ICEd)
        	{
        		if (!pieces[randomX][randomY].selectHighlight)        	
        		{
        		success=true;
        		pieces[randomX][randomY].ICEd=true;
        		pieces[randomX][randomY].updateCachedImage();
        		}//end if piece not selected
        	}//end if piece not iced
    	}//end while !success
    }
    
    //tiny little private class to record the position of frame of a special effect
    private class sfx
    {
    	public int x;
    	public int y;
    	public int frame;
    }
    
}//end class board
